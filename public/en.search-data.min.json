[{"id":0,"href":"/categories/","title":"Categories","parent":"WebAssembly","content":""},{"id":1,"href":"/How_to_install_Emscripten/","title":"How to install Emscripten","parent":"WebAssembly","content":"#!/bin/bash # Install git cmake build-essential python2.7 nodejs default-jre sudo apt-get install git cmake build-essential python2.7 nodejs default-jre wget https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz tar -zxvf emsdk-portable.tar.gz cd ./emsdk-portable ./emsdk update ./emsdk install sdk-incoming-64bit #If you are getting \u0026quot;collect2: error: ld returned 1 exit status\u0026quot; error, try running ./emsdk install -j1 sdk-incoming-64bit ./emsdk activate sdk-incoming-64bit cd emcscripten/incoming ./embuilder.py build binaryen cd ../.. source ./emsdk_env.sh "},{"id":2,"href":"/tags/","title":"Tags","parent":"WebAssembly","content":""},{"id":3,"href":"/Talk_jsdayes2017/","title":"Talk @ JsDayES, 2017, Madrid","parent":"WebAssembly","content":"Intro Me Hello, My name is Matjaz, I am working on road management software. This is a 3D viewer that shows scan of a road surface. We display those in browser, generate reports and stuff like that. When I heard of WebAssembly I was very interested because speed of calculations on the client side is very important for us. WebAssembly also makes in convenient to reuse existing C++ libraries in browser.\nWebAssembly basics WebAssembly is a format suitable for compilation to the web. It is like .exe, or whatever your device runs, that can run in browser. It is portable and runs in a sandbox, so it is secure. WebAssembly code runs in the same context as other JavaScript code, in the same thread. In fact it\u0026rsquo;s possible to seamlessly call functions in WebAssembly from JavaScript and the other way around. WebAssembly is not a programming language. It\u0026rsquo;s a binary format produced by a compiler. At the moment there exists a very good C++ compiler called Emscripten. There are also some game engines that support targeting WebAssembly, namely Unity engine and Unreal engine. This means we are about to see some very high quality games running in browsers. I hope you will be convinced how WebAssembly is awesome and fast by the end of this presentation.\nThis is a really impressive WebAssembly demo. It is a scene made with Unreal Engine 4. The same engine that was used to make the newest Unreal Tournament game. It\u0026rsquo;s in the top league of game engines and now it can run in a web browser! https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html\nNo plugins. No Flash, no Java. Just WebGL and WebAssembly. And if you are a game developer, making a portable game with engines such as Unity or Unreal Engine is really simple. You design your game and the engine is capable of producing version in WebAssembly, native, Android, Playstation and so on. And if you export your game in WebAssembly you have one binary that works on phones, tablets and PCs. And who knows, maybe someday even supercomputers. In fact WebAssembly is not restricted to browser environments. In theory it is even possible to make a hardware chip that would run WebAssembly directly without additional software. There is an experimental project called Wasmachine. https://github.com/piranna/wasmachine The goal is to run WebAssembly directly on a chip. For development they use FPGAs which are chips where you can reprogram their logic. The author of that project is Jesus In future and with enough money there could be processors that would just run WebAssembly instead of x86. The author of Wasmachine is Jesús Leganés-Combarro and he is presenting NodeOS in the next room at the moment.\nUsage scenarios At the moment WebAssembly can be used in a couple of different ways. Maybe you have an existing application and you want to speed up a certain algorithm in it. WebAssembly might help in scenario like that. Or maybe you want to reuse existing C++ library. There are still tons of things that we don\u0026rsquo;t do in Javascript just because of lack of libraries. Encryption is one such example. Only specialists implement encryption algorithms. Just a few weeks ago there was a conference called WebCamp in Ljubljana. There was also a presentation about security and the expert who was presenting said that you should never attempt to implement encryption algorithm yourself unless you have a couple of PhDs from math and computer science. Now that we have WebAssembly we don\u0026rsquo;t have to reimplement them, we can just recompile libraries that already exist. Third use case for WebAssembly is making apps that are essentially just WebAssembly with minimal amounts of JavaScript. If you are making something that uses OpenGL and some computation the Emscripten compiler will generate needed .HTML and JavaScript for you. So you only touch C++ code, compile it and run that in browser.\nDeep dive Now let\u0026rsquo;s work through an example of using WebAssembly in our existing apps. Let\u0026rsquo;s say you have a web application. It mostly runs OK but there is an algorithm that is just too slow in JavaScript. We want to try writing it in C++ and see if that helps.\nThis is our example app. It prints the biggest prime number that is smaller than N. For example if I type 10, the biggest prime number less or equal to 10 is 7. The application uses an algorithm called Sieve of Erathostenes. It loops through all numbers from two to whichever we want. First we have two, we know it\u0026rsquo;s a prime but we also know that all other even numbers are not primes so we cross them over. Then we go to number three. It\u0026rsquo;s a prime, but six, nine, twelve and so on are not. And then we get to number four which was already crossed out. And so on until we check all primes until N. Then we print out the biggest one we found.\nThis is an implementation of the algorithm in JavaScript. The input is N and the output is the biggest prime less or equal than N. First we make an array with elements with indexes up until N. This means the array will have N+1 elements and we will just ignore the 0 at the beginning. It makes the code easier to read because we don\u0026rsquo;t have any offsets. This is the outer loop that goes from two to N. If we know the number is not prime, we do nothing. If it is prime, we go to the inner loop and cross over all it\u0026rsquo;s multiples.\nThis implementation will be fine for small numbers but for bigger ones C++ will give us some extra performance. Algorithms like that are ideal candidates for optimizing by rewriting them in C++.\nTo do that we need a compiler to produce WebAssembly from some programming language. We will use Emscripten to compile C++ code. Emscripten is based on a suite of compiler components called LLVM. This means we are actually getting a very good and stable C++ compiler. LLVM has a long history and it supports new C++ features that were added in the last couple of years. Emscripten basically just adds support for generating WebAssembly output in addition to native machine code. It also ships with standard C++ library and implements some common multimedia APIs such as OpenGL and it does that just by calling WebGL. LLVM is not limited to C++, in fact there are LLVM-based compilers for other languages but I am not aware whether you can compile to WebAssembly from any of them.\nYou can see the procedure for installing Emscripten in this slide. At the moment we have to install Emscripten from incoming branch because Webassembly support hasn\u0026rsquo;t been added to the stable version yet. The slides will be online. I alredy installed Emscripten on this computer to make sure nothing goes wrong.\nThe implementation in C++ is mostly the same. I just copy pasted the code, added types and changed how array is initialized. At the end I used emscripten bindings to expose my function so that it can be called from Javascript.\nExposing a function that takes a number and returns a number is really simple. Emscripten is able to figure out datatypes and conversions between C++ and Javascript. For classes and more complex structures you need to put in some more work but it\u0026rsquo;s not too complicated. More information about exposing C++ APIs to JavaScript is available on Emscripten home page. https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html\nThen we compile this code using emcc and we get .js and .wasm file. Generated JavaScript file will take care of loading the .wasm module and exposing all the functions and classes that you exposed to JavaScript.\nWe edit index.html by adding \u0026lt;script\u0026gt; tag that loads the generated Javascript file and replace call to Javascript implementation with C++ implementation.\nThis example is not really realistic but I think you get the idea. More realistic example is a video editor that implements effects using WebAssembly.\nVideo editor https://d2jta7o2zej4pf.cloudfront.net/\nHere we have a selection of effects that we can apply to a video. And on the right side we see two charts. The blue one shows framerate if video is processed in Javascript and the green one shows framerate when we process video in C++ and ship that as a WebAssembly binary. Multimedia is really an extreme example where a lot of data has to be moved. It\u0026rsquo;t really an ideal use case for technology such as WebAssembly. But WebAssembly is not only about performance. It might also be about saving battery. If some calculation is performed faster it means that processor has to run at full frequency for less time. And that will make users of mobile devices very happy.\nLet\u0026rsquo;s take a closer loop at WebAssembly format. https://mbebenita.github.io/WasmExplorer/\nint sum(int a, int b) { return a+b; } This is a tool called WasmExplorer. What we see is a function in C++ and then the same function compiled to WASM and x86 binary. We can see precisely that the compiler already figured out that we want to take two parameters and do 32-bit integer addition. If you imagine a similar function in JavaScript, the types of arguments can be anything and the JavaScript engine has to figure out what the plus sign actually means. It can be summation of numbers, it can be concatenation of strings or something invalid. And after it figures that out it also needs to decide whether any of the parameters need to be converted into another data type. Only after all these steps it can actually perform the operation. In contrast compiler does all those decisions up front in the WebAssembly case. Going from WebAssembly to native machine code is mostly glorified search and replace.\nAnother important consideration besides performance is security. Why is WebAssembly secure? There are a couple of reasons. First, WebAssembly has a limited set of instructions compared to native x86. It only supports numerical operations, branching and loops. Second, functions calls are controlled. WebAssembly programs can only communicate with environment using imported and exported functions and a block of linear memory. WebAssembly code is loaded with a special JavaScript API and when we run WebAssembly program, we also need to specify table of functions that WebAssembly program can call. And because we are in JavaScript there is no way to put there anything else than what is already accessible there. WebAssembly programs cannot call anything that you can\u0026rsquo;t call from JavaScript already and they are restricted by same cross origin policies and similar checks. Another important property of WebAssembly is that linear memory for the data is separated from program code. This is important because it makes it harder to corrupt the program code itself if something goes wrong. In native x86 architecture program code and data is not separated. You can have bytes of data that were entered by the user or read from file and after that you can have binary instructions for some function that you call later. But if there is a bug in the program and the program reads input that is longer than the reserved space, It will overwrite its own instructions. This is called buffer overflow and it is one of the most common reasons for security issues with software. However, because data memory of a WebAssembly program is separated from the program itself, such problems should not occur.\nOpenCV demo Now let\u0026rsquo;s take a look at another more fun demo. Here we are taking live video from the Webcam on this laptop and performing face detection. For face detection I used a library called OpenCV. It\u0026rsquo;s written in C++ and obviously I wouldn\u0026rsquo;t want to rewrite it to JavaScript. Fortunately, because of WebAssembly, I can just compile it with Emscripten and use it in browser.\nWe are getting video from camera and then we send video frame to some C++ code that runs OpenCV algorithm for detecting faces. C++ returns coordinates of those faces and the eyes and we render them on a canvas. Computer vision code is running in a WebWorker to keep the browser responsive. WebWorker is some JavaScript code that takes care of passing data between computer vision algorithm in WebAssembly format and JavaScript that runs on the page. WebAssembly is produced by compiling OpenCV and a tiny C++ program that uses the library to do exactly what we need here and exposes those functions to JavaScript.\nBrowser support, polyfilling According to caniuse.com 52% of internet users can already run WebAssembly. It was developed in consensus between Chrome, Edge, Firefox and WebKit. This means that support is coming to all major browsers. For older browsers you can also compile to asm.js which should work on all browsers that have typed arrays.\nConclusion Problems I faced Before I conclude I will say a few words about problems I faced when experimenting with WebAssembly. One of the problems was that I was expecting documentation at WebAssembly.org. But as it turns out as a developer you should mostly read documentation provided by your compiler, for example Emscripten. Which Emscripten I needed to figure out what various parameters mean. Example of an important parameter is -s NO_EXIT_RUNTIME=1. Normally, without this option, Emscripten will clean up everything after main() function in C++ code terminates. This is fine, if you wrote the whole application in C++ but it\u0026rsquo;s bad if you are calling specific functions from JavaScript when you need them. That option will prevent cleaning up of memory and other important stuff after main() is done.\nI\u0026rsquo;ve been also spending time on finding ways to efficiently transfer data between JavaScript and C++. These data transfers are very expensive when you are trying to transfer pixels at 60 frames per second. You want to do the least amount of copying as possible.\nAnother awkward subject when interfacing C++ and JavaScript are objects. JavaScript has a garbage collector that detects which objects cannot be accessed and deletes them automatically. However in C++ memory management is manual. You need to know which objects have to be manually deleted and when. Otherwise you either run out of memory or try to access an object that does not exist anymore.\nIn bigger applications that use Angular I found it convenient to wrap calls to WebAssembly inside a service. That way angular calls a function before service or a component is destroyed so I know exactly when I need to clean up WebAssembly stuff.\nSuggested path for learning all this WebAssembly is an opportunity to learn new programming languages. I would say it\u0026rsquo;s best to learn C++ first without WebAssembly and just learn how C++ programmers think and what tools they use and only add WebAssembly later. Limiting yourself like that is a good tactic to not get overwhelmed by all new stuff that you need to learn. Make sure the literature is up to date because a lot has changed in the last 6 years in the C++ land. There were lots of improvements to the language and the standard library.\nPlanned WebAssembly features WebAssembly as it is now is only a so called minimum viable product. It\u0026rsquo;s a start but to make it really useful it still needs some work. Currently the browser vendors are working on multithreading and SIMD instructions.\nThreads Browsers already have support for WebWorkers which is a way of multithreading but it is limited. Data between WebWorkers cannot be shared. It can be copied or moved but two WebWorkers cannot work on same piece of data at the same time. WebAssembly will have actual threads as they exist in other languages. This will offer great speed improvements, way beyond of what is available now. In optimistic benchmarks WebAssembly is 10, 20, 30 or so percent faster. Multithreading will speed up some algorithms 2, 4 or 8 times, depending on have many cores you have on your processor.\nSIMD instructions Another important feature that is planned is support for SIMD instructions. Modern processors have special instructions that can execute same operation on multiple pieces of data. Let\u0026rsquo;s imagine we have two three-dimensional vectors and we want to compute their SUM. How do you do that? First you take x components of both vectors and add them together. Then you do the same for Y and then you do the same for Z. But if you have access to SIMD instructions you can do all three in one step. Again this speeds up computations a lot. All algorithms involving graphics or sound or linear algebra have tons of computations like that. SIMD instructions mean we can again expect speed-ups of around 4-times for ideal case.\nBoth of these features mean that we will get around 16-times faster calculations. Of course this will only be valid for ideal algorithms. But surely it will be noticeable for the multimedia.\nMore tooling, more compilers Currently Emscripten is a very decent C++ compiler and there is a compiler for Rust as well. There was an experiment to bring languages from .NET ecosystem to WebAssembly but unfortunately that project doesn\u0026rsquo;t seem to be active. I am hoping there will be more and more compilers after as time passes.\nConclusion Hopefully this talk will inspire you to try WebAssembly and get inspired by new possibilities. Although C++ can look frightening, it becomes fun when you know that you can control what you program does. It gives you kind of power that you don\u0026rsquo;t get from languages such as JavaScript. You can control exactly when piece of memory is allocated and when something is deleted. You know exactly how many bytes you an instance of you class needs. You get to tweak your code and watch compiler\u0026rsquo;s output and see when you get most done with least amount of processor instructions.\nI invite you to hack and make better developer tools related to this technology. I just recently heard that developer tools in Firefox are actually a separate project on GitHub. It\u0026rsquo;s a React application so any JavaScript developer can change it. And I am hoping someone will bring Go, Haskell and other cool languages to the web as well.\nThank you "},{"id":4,"href":"/Talk_LjPyMeetup2019/","title":"Talk @ LjPyMeetup, 2019, Ljubljana","parent":"WebAssembly","content":"Intro slide: Hi, I\u0026rsquo;m Matjaž Drolc. I\u0026rsquo;m working on software for optimizing the maintenance of roads. We gather the data from measurements of road surfaces and do some magic to predict how the asphalt is going to perform in the future. The data that we get is not perfect. To obtain good results we need a way to see what is happening. This is why we started using Python. Tools such as Pandas and Jupyter enable us to have fast feedback during development. [show Jupyter notebook]\nAfter the prototype is done, we need to make a product out of it. Algorithms from the prototype need to be deployed sometimes on servers and sometimes in the browser. This brings us into an awkward situation. The only way to run code in a browser was to use JavaScript. There exists a transpiler that converts Python code to JavaScript and there are at least two Python interpreters written in JavaScript. However, due to the lack of Numpy and Pandas, those solutions don\u0026rsquo;t really help us.\nAnother option is manually rewriting the Python prototypes to JavaScript. But that option is the worst of all. First and foremost, it\u0026rsquo;s a waste of time. Probability of mistakes is high. Process of rewriting numpy and pandas code to JavaScript would entail finding some good library for JavaScript and currently, I am not aware of the existence of anything at that level. Even if something like that existed, one would need to know all the tiny details of both numpy and this non-existent JS library to accurately reimplement the code. To make matters worse, there are also differences between the languages themselves. Because both Python and JavaScript are dynamic languages, there are many hidden rules around type conversions that one has to be aware of.\nHowever, things are changing.\nThe hell froze in 2017. Developers of Chrome, Edge, Firefox, and Safari started talking to each other after more than a decade of incompatible web browsers. They announced a thing called WebAssembly. WebAssembly is a new format for distributing program code as part of web applications.\n[Open HelloWorld in WASM explorer https://mbebenita.github.io/WasmExplorer/]\nWebAssembly is a low-level format. It\u0026rsquo;s not designed to be written by hand. The idea is to use some kind of compiler, that produces WebAssembly binary and then run that program in a browser, similar to the way that JavaScript runs. On the left, we see a C++ function that takes a list of numbers and sums them together. In the middle is that same function compiled to WebAssembly. This is what you distribute as part of your web application. On the right is what browser computes internally before actual execution. After a web browser downloads a WebAssembly file, it performs validation and all security checks and produces fast machine code.\nThe main point here is that we now have open doors to run whatever programming language we want in a web browser. We just need a compiler. For C and C++ we have a suite of compiler and tools called Emscripten. It has existed for many years now and is quite stable. Rust compiler is also quite mature and people are also working on compilers for Go, Kotlin and .NET languages (C#, F#\u0026hellip;).\nDoes anybody know which important piece of software is written in C? It\u0026rsquo;s the official Python interpreter - CPython.\nPyodide is a project that aims to bring the Python scientific stack to the web browser. So far they already ported Python interpreter, Numpy, Scipy, Pandas, matplotlib and other libraries.\nBoth Jupyter and Pyodide look similar on the surface. Developer tools (F12) reveal the most significant difference.\nEach time I execute some code in Jupyter, that code is sent to the server, executed there and the result is sent back to the browser. With Pyodide there is no communication with the server. Everything, including Python interpreter, runs in the browser. And we are talking about official Python interpreter, built from the same source code, that you use elsewhere.\n[Show demo with developer tools on the network tab and Jupyter] [Show demo with developer tools on the network tab and Pyodide]\nIf you run Python interpreter in the web browser, you gain some superpowers. You can seamlessly interact with JavaScript. Converting data between Python and JavaScript is taken care of. It is also possible to manipulate elements on a web page from Python. Any global JS object can be imported from Python code. Here we import document which we can use to manipulate DOM elements. The document has exactly the same API that we are used to in JS. Handling event is equally simple. In the example, we use a Python function as a callback for the click event.\nWe can get more advanced and combine several mouse events to produce a simple app for doodling.\nWe can flip things around and call Python code from JavaScript.\nAfter Pyodide is loaded, it exposes an object called \u0026lsquo;pyodide\u0026rsquo;. API: https://github.com/iodide-project/pyodide/blob/master/docs/api_reference.md#javascript-api\nWith a call to pyodide.pyimport(name) we can access any Python object. Here we first create a class called Foo and create an instance called foo. Then we request that object from JS side and read the \u0026lsquo;val\u0026rsquo; attribute.\nThe reason I use Python are mostly its scientific libraries. Pyodide includes many packages, including Numpy, Pandas, SciPy and matplotlib. Here is a tiny numpy example. First we calculate values of sine function and then we display those with matplotlib. You can see a list of all ported packages on Github. https://github.com/iodide-project/pyodide/tree/master/packages\nLet\u0026rsquo;s summarize the benefits of running Python on the client side. First of all, hosting our application gets cheaper. Computation is happening on the client. Another big win is related to security. In a scenario like Jupyter, the code we are running is not trusted. If we run it on a shared server, we need to isolate users from each other and also prevent doing damage to the server. Docker partially addresses this, but there are security holes or maybe wrong configuration, that can open doors to attackers. On the other hand, web browsers take security very seriously. Whenever Google, Mozilla, Microsoft, and Apple talk about implementing new features, the main obstacle is how to do so in a way that protects users. We obviously don\u0026rsquo;t want to give code from websites complete access to our devices. All WebAssembly code is running in a sandbox. Access to files, graphics card, camera, and the network is controlled in the same way as in JavaScript.\nPerformance is one of the main selling points of WebAssembly. [Video demo: https://d2jta7o2zej4pf.cloudfront.net/ ] Here we can play with some video effects. The green chart shows us framerate for WebAssembly version and the blue one for JavaScript. The WebAssembly version has a much better frame rate than the JavaScript version.\nAnd to make things crazy, they also ported WebM video codec to WebAssembly. There are no obstacles to making music or a video editor in a web browser.\nWe are also getting some new games. Unity and Unreal Engine both support WebAssembly. DEMO: https://s3.amazonaws.com/mozilla-games/ZenGarden/EpicZenGarden.html\nThere are still some open issues that will need to be solved in the future. The Python demos that we looked at, downloaded 10s of MBs of files. This is because a web app needs to load Python interpreter and libraries before it can run them. Maybe the web will have a standard set of libraries packed together with browsers. But I don\u0026rsquo;t expect this will happen soon, because it would be very hard to define any standard for that. Another issue is performance. While WebAssembly is quite performant, there is still a performance penalty between 2 and 12-times compared to running Python interpreter directly on hardware. And because of security, access to the network is very limited. We can use HTTP(S) and WebSockets, or in other words, exactly what we already had in JavaScript. It won\u0026rsquo;t become possible to implement BitTorrent client in WebAssembly. Another thing that doesn\u0026rsquo;t work yet is multithreading. But the issue is temporary because browser vendors are preparing a standard that will solve this issue.\nOther important WASM projects:\n https://wasi.dev/ - WebAssembly System interface. Currently, the way that WebAssembly code communicates with the system around it is not standardized. People who write compilers created some ad-hoc solutions. But WASI project is aiming to standardize this. https://wasmer.io/ is an universal WebAssembly runtime. They are trying to run WebAssembly outside of web browser. For example on servers. https://github.com/mohanson/pywasm is a WebAssembly interpreter written in pure Python. If you want to run your Python code in Python that runs in WebAssembly that runs in Python, you can.  I think the future will be interesting. In the near term, we will see better viewers of Jupyter notebooks and more web apps where we can play with data. We might see improvements to Python documentation. The path is open to make it richer by embedding interactive code snippets. We will also see the transition of software, that was traditionally running on the desktop, to the web. For example, software for video/audio editing, CAD, scientific computation\u0026hellip;\n"},{"id":5,"href":"/","title":"WebAssembly","parent":"","content":"Introduction WebAssembly is a format suitable for compilation to the web. It is like .exe (or whatever your device runs) that can run in browser. It is portable and runs in a sandbox, so it is secure. WebAssembly code runs in the same context as other JavaScript code, in the same thread. In fact it\u0026rsquo;s possible to seamlessly call functions in WebAssembly from JavaScript and the other way around. WebAssembly is not a programming language. It\u0026rsquo;s a binary format produced by a compiler. At the moment there exists a very good C++ compiler called Emscripten. There are also some game engines that support targeting WebAssembly, namely Unity engine and Unreal engine. This means we are about to see some very high quality games running in browsers.\nLinks  Serverless Jupyter, slides, LjPyMeetup April 2019 Slides, JSDayES 2017 Recording of the talk Demo: Primes (without WASM) Demo: Primes (with WASM) Demo: Face detection Awesome WASM @ GitHub  "}]